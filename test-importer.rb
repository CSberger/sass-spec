#!/usr/bin/env ruby

#This script wil transform a collection of folders and input files to sass implementations
#under a specified directory in such a way that they can be tested with the accompanying
#testrunner.rb script. The transformed hierarchy will be put in a specified location.
#
#For reference, this script will transform a hierarchy that looks like this:
#...
#|-folder1
#| |-subfolder1
#| | |-test1.scss #same file as
#| | |-test2.scss
#| |-subfolder2
#| | |-test1.scss
#| |-test1.scss
#| |-test2.scss
#|-folder2
#...
#
#Into one that looks like this:
#...
#|-folder1
#| |-subfolder1
#| | |-test1
#| | | |-input.scss #this file
#| | | |-expected_output.css #output of the input.scss above when run through sass
#| | |-test2
#| |   |-input.scss
#| |   |-expected_output.css
#| |-subfolder2
#| | |-test1
#| |   |-input.scss
#| |   |-expected_output.css
#| |-test1
#| | |-input.scss
#| | |-expected_output.css
#| |-test2
#|   |-input.scss
#|   |-expected_output.css
#|-folder2
#...
#Note that folder2 in the above example would only be created if there was at least one scss file
#somewhere under it in the original file hierarchy (this example assumes there is).

def helpmessage
	"\nThis script will take a collection of input files to sass implementations and change the\n"+
	"hierarchy in such a way that sass-spec.rb can be used to run batches of tests. The\n"+
	"expected_output.css files are generated by running sass (whichever version you have) on the\n"+
	"input files. Sass is assumed to be on your path. View the initial comment of this script for\n"+
	"more detailed info.\n\n"
end

def getusage
	"Usage: test-importer.rb [Options]\n"+
	"\n"+
	"Options:\n"+
	"\t-s=, --source=\t\tSets the directory to recursively search for .scss files (defaults to '.')\n"+
	"\t-d=, --dest=\t\tSets the directory to place the new hierarchy in (defaults to './test-suite/')\n"+
	"\t-v, --verbose\t\tPrint more info\n"+
	"\t-h, --help\t\tDisplay the help message\n"
end

def exampleusage
	"Example usage:\n"+
	"./test-importer.rb -s=myinputcollection\n"+
	"./test-importer.rb -d=mytestsuite -v\n"+
	"./test-importer.rb -s=myinputcollection -d=mytestsuite\n\n"
end

def usage s, c
	$stderr.puts s + getusage
	exit c
end

#can't find a parser that does exactly what I want (no partial option matching, forcing the '=' to be there,
#disallowing passing nothing, helpful error message based on what exactly went wrong, ...), so write my own
def parse
	opts = {}
	
	opts[:src] = '.' #set to the default src of .
	opts[:dst] = './test-suite/' #set to the default destination of ./test-suite/
	opts[:verbose] = false
	
	ARGV.each do |arg|
		if arg =~ /^-(s|-source)=/
			opts[:src] = ARGV.shift.split("=",2)[1]
			if opts[:src] == ""
				usage "\nERROR: Must specify a source directory as -s=<SRC> or --source=<SRC>.\n\n", 1
			end
		elsif arg =~ /^-(d|-dest)=/
			opts[:dst] = ARGV.shift.split("=",2)[1]
			if opts[:dst] == ""
				usage "\nERROR: Must specify a destination directory as -d=<DST> or --dest=<DST>.\n\n", 1
			end
		elsif arg =~ /^-(h|-help)$/ then
			puts helpmessage + getusage + exampleusage
			exit 0
		elsif arg =~ /^-(v|-verbose)$/ then
			opts[:verbose] = true
		else
			usage"\nERROR: Unknown option: #{ARGV[0].inspect} (make sure to include the '=' for options that require it)\n\n", 2
		end
	end
	
	if !opts[:src].end_with?(File::Separator) then 
		opts[:src]+=File::Separator
	end
	
	#not strictly necessary test, but allows a more tailored error message
	if File.exists?(opts[:dst]) && !File.directory?(opts[:dst])
		$stderr.puts "\nERROR: Destination specified needs to not be a file. You specified #{opts[:dst]}.\n"
		exit 3
	end
	opts
end

# copy all *.scss files under the source dir and return a 1 or 0 
# depending on whether or not sass exited successfully, respectively
def copyFile test_file, opts
	#get the part of the path that doesn't have the section dictated by source
	#(do this to preserve the existing file hierarchy in src)
	rest_name = test_file[opts[:src].length..-1]
	test_dest_dir = File.join opts[:dst], rest_name.chomp!(".scss")
	`mkdir -p #{test_dest_dir};`
	if !$?.success?
		$stderr.puts "There was a problem making a needed directory (#{test_dest_dir} in particular). Aborting rest of script.\n"+
			     "  Make sure you have permissions or use 'sudo' if necessary."
		exit 2
	end
	`cp #{test_file} #{File.join test_dest_dir,"input.scss"}`
	if !$?.success?
		$stderr.puts "There was a problem copying #{input_file} to #{test_dest_dir}. Aborting rest of script.\n" +
			     "  Make sure you have permissions or use 'sudo' if necessary."
		exit 3
	end
	`sass #{File.join test_dest_dir,"input.scss"} > #{File.join test_dest_dir, "expected_output.css 2> /dev/null"}`
	if !$?.success?
		$stderr.puts "ERROR: sass didn't like the input #{File.join test_dest_dir, "input.scss"} and exited unsuccessfully.\n"+
		"       This input file will not be part of the generated test suite."
		`rm -r #{test_dest_dir}`
		return 0
	end
	if opts[:verbose]
		puts "Copied #{test_file} to #{File.join test_dest_dir, "inputs.scss"} and made a corresponding expected_output.css."
	end
	1
end

def run opts
	puts "Recursively searching under directory '#{opts[:src]}' for scss files to move to directory '#{opts[:dst]}'."
	
	test_count = 0
	total_test_count = 0
	
	Dir["#{opts[:src]}**/*.scss"].each do |test_file|
		total_test_count += 1
		test_count += copyFile test_file, opts
	end
	
	puts "Found #{total_test_count} total .scss files under #{opts[:src]}. Copied #{test_count} input files.\n"+
	     "There may be empty directories, remove them if it bothers you.\n"
end

run parse
